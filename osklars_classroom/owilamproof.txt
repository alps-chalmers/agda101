boolean y; int x;
a: cobegin
    b: while < x<10 > do b2: < y:=true > od;
    c: < y:=false >
    #
    d: while < y > do d2: < x:=x+1 > od;
coend

does not terminate for all init where y = true and x < 10.

better example is:

boolean y; int x;
i1: < y:=true >;
i2: < x:=0 >;
a: cobegin
    b: while < x<10 > do nope od;
    c: < y:=false >
    #
    d: while < y > do d2: < x:=x+1 > od;
    (d': < y:=true >)
coend

proving (at i1) leads to (after a)

1. (at i1) leads to (at b) ^ (at d)

2. always(in b implies y=true) ^ (in b) ^ (in d) leads to (always x>=10)

3. (at b) ^ (always x>=10) leads to (at c)

4. (at c) leads to (always not y) ^ (after c)

5. (in d) ^ (always not y) leads to after d

6. after c ^ after d = (after a)


with d':

1. (at i1) leads to (at b) ^ (at d)

2. always(in b implies y=true) ^ (in b) ^ (in d) leads to x>=10

3. (at b) ^(always x >=)





























rules:
1. at atomic leads to after atomic
2. at b implies (x=possible values at b)
3. (in loop) ^ (ALWAYS loopcondition=false) leads to after loop
4.





















p1: x:=1
p2: x:=2
p3: if y=0
p31:  x:=3

not concurrent:
at p1 leads to x=1
